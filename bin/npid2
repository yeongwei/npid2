#!/bin/bash

############################################################
## C O N S T A N T S #######################################
############################################################
## New variables that are global
############################################################

# Application names
ZOOKEEPER_APP_NAME="zookeeper"
KAFKA_APP_NAME="kafka"
HADOOP_APP_NAME="hadoop"

# Application names (human readable)
ZOOKEEPER_READABLE="Zookeeper"
KAFKA_READABLE="Kafka"
HADOOP_READABLE="Hadoop"

# Reflects folder names inside docker directory
ZOOKEEPER="zk"
KAFKA="kafka"
HADOOP="spark_hadoop"
NPI="npi"

# Global stuffs around
TRY_COUNT=10
SLEEP_TIME=5

SCRIPT=$0
# Routine below facilitates the full qualified paths
if [ "`echo $0 | cut -c1`" = "." ]; then
   SCRIPT="`pwd`/`echo "$0" | sed 's/\.\///g'`"
elif [ "`echo $0 | cut -c1`" != "/" ]; then
   SCRIPT="`pwd`/$0"
fi

BIN_DIR=`dirname $SCRIPT`
PROG_DNAME=`basename $SCRIPT`
PROG_NAME=`echo $PROG_DNAME | sed s/.$//`
PROG_NAME2=`echo $PROG_NAME | sed s/d$//` # The correct product name
PROG_HOME=`dirname $BIN_DIR`
PROG_VERSION=`cat $BIN_DIR/$PROG_NAME2 | grep ^PROG_VERSION= | awk -F"=" '{print $2}'`

############################################################
## E N V # C O N D I T I O N I N G #########################
############################################################
# Re-using existing bootstraps from docker
DOCKER_DIR=${PROG_HOME}/docker
BOOTSTRAP="bootstrap.sh"
ENV_FILE="npi_env.sh"


# New environmental variables
SH_SHELL=`which sh`
BASH_SHELL=`which bash`
SERVICES_DIR=${PROG_HOME}/services

# New exports
export NPI_HOME=${PROG_HOME}
export NAMENODE=true
export USER_CONFIG=false
export HADOOP_PREFIX=${SERVICES_DIR}/hadoop
export STORAGE_URL=$HADOOP_NAMENODE_URL
export ZK_URL=$ZOOKEEP_URL
export ZKPREFIX=""

LOG_DIR=${PROG_HOME}/log
CONSOLE_LOG=${LOG_DIR}/${PROG_DNAME}.log
VAR_DIR=${PROG_HOME}/var

ZOOKEEPER_LOG=${LOG_DIR}/${ZOOKEEPER_APP_NAME}.log

if [ ! -d "${LOG_DIR}" ]; then
  mkdir -p ${LOG_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0100E: Create directory $LOG_DIR failed!  Check permissions on parent directory."
    exit 1
  fi
fi

if [ ! -d "${VAR_DIR}" ]; then
  mkdir -p ${VAR_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0101E: Create directory $VAR_DIR failed! Check permissions on parent directory."
    exit 1
  fi
fi

############################################################
## E X I S T I N G # F U N C T I O N S #####################
############################################################
log() {
  severity=$1
  shift
  timestamp=`date "+%Y-%m-%d %H:%M:%S.%N"|cut -b1-23`
  echo "[${severity}] [${timestamp}] [npid] $@" | tee -a ${CONSOLE_LOG}
}

showVersion() {
  log INFO "GYMPB0102I: Application: ${PROG_NAME2} Version: ${PROG_VERSION}"
  exit 0
}

############################################################
## N E W # F U N C T I O N S ###############################
############################################################

##
## E.g.
## npid start - starts all framework + npi
## npid start zookeeper
## npid start kafka
## npid start hadoop
##
## npid start npi - only starts npi
## npid start npi-storage
## npid start npi-analytics
## npid start npi-collector
## npid start npi-ui
##	
npidUsage() {
	echo "Usage: npid {start|stop|restart|kill|status|version|help} [<component_name>|<service_name>]"
	echo "component_name: npi, npi-storage, npi-analaytics, npi-collector, npi-ui"
	echo "service_name: zookeeper, kafka, hadoop"
	echo ""
	echo "Example: "
	echo "	1) npid start"
	echo "	2) npid start npi"
	echo "	3) npid start zookeeper"
	echo "	4) npid stop"
}

##
## Check based on application name if, 
##	1. appplication PID file exist 
##	2. PID file is not empty
##	3. PID is found under ps ax
## Return 1 if found else 0
## E.g. 
##	isPidValid zookeeper
##	isPidValid npi-storage
##
isPidValid() {
	pidFile=${VAR_DIR}/${1}.pid

	if [ -f ${pidFile} ]; then 
		pid=`cat ${pidFile}`
		if [ -z "${pid}" ]; then # pid file is empty
			echo 0
		else # pid file not empty
			if [ -z "`ps ax | grep ${pid} | grep -v grep`" ]; then # pid is not within ps
				echo 0
			else # pid is valid within ps
				echo 1
			fi
		fi	
	else # no pid file exists
		echo 0
	fi
}

##
## If 1 then log ERROR then exit with -1
## E.g. emergencyExit $status "GYM ..."
##
emergencyExit() {
	if [ ${1} -eq 1 ]; then
		log ERROR ${2}
		exit -1
	fi
}

##
## Created PID file based on application name. E.g. kafka.pid
##
writePID() {
	if [ $# -eq 2 ]
	then
		echo $2 > ${VAR_DIR}/${1}.pid # do we use >> instead ???
	else
		log ERROR "GYMPB0000E: Not enough arguments to write into PID file."
		exit 1
	fi
}

##
## Remove PID file based on application name. E.g. hadoop.pid
##
removePID() {
	rm ${VAR_DIR}/${1}.pid
}

##
## Get pid from PID file. E.g. hadoop.pid
##
getPID() {
	echo `cat ${VAR_DIR}/${1}.pid`
}


##
## Kill(15) pid and it's associated processes
##
killAssociatively() {
	ps -ef | grep ${1} | grep -v grep | awk '{print $2}' | xargs -i kill -15 {}
}
##
## Check if Zookeeper has started
## USAGE: checkZookeeperStarted <CMD> <PATTERN> <APPLICATION>
##
checkZookeeperStarted() {
	tryCount=${TRY_COUNT}
	isZookeeperUp=0
	host=`echo ${ZOOKEEP_URL} | cut -d: -f1`
	port=`echo ${ZOOKEEP_URL} | cut -d: -f2`

	while [ ${tryCount} -ne 0 ]; do
		ncResult=`echo ${1} | nc ${host} ${port} | grep ${2}`
		if [ ! -z "${ncResult}" ]; then
			isZookeeperUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isZookeeperUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: ${3} is not starting."
		exit 1
	else
		log INFO "GYMPB0000I: ${3} has started"
	fi
}
# ===================
# = Zookeeper =======
# ===================
startZookeeper() {
	status=`isPidValid "${ZOOKEEPER_APP_NAME}"`
	emergencyExit ${status} "GYMPB0000E: ${ZOOKEEPER_READABLE} is already running."

	log INFO "GYMPB0000I: About to start ${ZOOKEEPER_READABLE}"
	cd ${SERVICES_DIR}/${KAFKA_APP_NAME} && ./bin/zookeeper-server-start.sh ${SERVICES_DIR}/conf/${KAFKA_APP_NAME}/${ZOOKEEPER_APP_NAME}.properties >>${ZOOKEEPER_LOG} 2>>${ZOOKEEPER_LOG} &
	writePID ${ZOOKEEPER_APP_NAME} ${!}
	checkZookeeperStarted "stat" "Mode:" ${ZOOKEEPER_READABLE}
}

stopZookeeper() {
	log INFO "GYMPB0000I: About to stop Zookeeper"
	# reference from https://github.com/linkedin/linkedin-zookeeper/blob/master/org.linkedin.zookeeper-server/src/cmdline/resources/bin/zkServer.sh
	pid=`getPID ${ZOOKEEPER_APP_NAME}`
	log DEBUG "GYMPB0000I: Attempting to kill processes associated with ${pid}"
	killAssociatively ${pid}

	tryCount=${TRY_COUNT}
	isZookeeperDown=0
	
	while [ $tryCount -ne 0 ]; do
		psStatus=`ps ax | grep ${ZOOKEEPER_APP_NAME} | grep -v grep | grep -v ${PROG_NAME}`
		if [ -z "${psStatus}" ]; then
			isZookeeperDown=1
			break
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isZookeeperDown} -eq 0 ]; then
		log ERROR "GYMPB0000E: Zookeepeer is not stopping."
		exit 1
	else
		log INFO "GYMPB0000I: Zookeepeer has stopped."
		removePID ${ZOOKEEPER_APP_NAME}
	fi
}

# ================
# = Kafka ========
# ================
startKafka() {
	a=1
}

stopKafka() {
	a=1
}

# ==============
# = Hadoop =====
# ==============

##
## There are initial errors not able surpress by this script ***
##
checkHadoop() {
	isHadoopUp=0
	tryCount=${TRY_COUNT}
	cmd="${HADOOP_PREFIX}/bin/hdfs dfsadmin -report"
	
	while [ ${tryCount} -ne 0 ]; do
		dfsAdminResult=`${cmd}`
		if [ ! -z "${dfsAdminResult}" ]; then
			isHadoopUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isHadoopUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: Hadoop is not starting."
		exit 1
	fi
	
	isHadoopUp=0
	tryCount=${TRY_COUNT}
	cmd="${HADOOP_PREFIX}/bin/hdfs dfs -ls ${HADOOP_NAMENODE_URL}"

	while [ ${tryCount} -ne 0 ]; do
		dfsResult=`${cmd} | grep "work"`
		if [ ! -z "${dfsResult}" ]; then
			isHadoopUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isHadoopUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: Hadoop is not starting."
		exit 1
	fi
}

startaHadoop() {
	a=1
}

stopHadoop() {
	a=1
}

# ===============
# = Npi =========
# ===============
startNpi() {
	a=1
}

stopNpi() {
	a=1
}

# ==========================
# = Start Rountine =========
# ==========================
# Each case responsible of start procedure for each application
startRoutine() {
	case "${1}" in
		"${ZOOKEEPER_APP_NAME}")
			startZookeeper
		;;
		*)
			log INFO "GYMPB0000I Application name is missing."
			npidUsage
		;;
	esac
}

# ==========================
# = Stop Rountine ==========
# ==========================
stopRountine() {
	case "${1}" in 
		"${ZOOKEEPER_APP_NAME}")
			stopZookeeper
		;;
		*)
			log INFO "GYMPB0000I Application name is missing."
			npidUsage
		;;
	esac
}

# Check if any components related to Npi is running
checkIfAnyNpiRunning() {
	a=1
}

getPID() {
	if [ -f ${VAR_DIR}/${1}.pid ]; then
		echo -e `head -1 ${VAR_DIR}/${1}.pid` # cat or head ???
	else
		log ERROR "GYMPB0000E: PID does not exist."
		exit -1
	fi
}

##
## Each service or component should have it's own dedicated pid file
## 
##
checkStatus() {
	if [ -f ${VAR_DIR}/${1}.pid ]; then
		pid=`getPID ${1}`
		log INFO "GYMPB0116I: Application ${1} is running on pid ${pid}."
	else
		log INFO "GYMPB0117I: Application ${1} is not started."
	fi		
}

##
## Status dump for all components and services that is found in /var/*
##
checkAllStatus() {
	allAvailPidFile=`ls -1 ${VAR_DIR}`
	allAvailPidFile2=(${allAvailPidFile[*]}) # Transpose into array

	if [ ${#allAvailPidFile2[@]} -eq 0 ]; then
		log INFO "GYMPB0117I: No application started."
	else
		for pidFile in "${allAvailPidFile2[@]}"; do
			appName=`echo ${pidFile} | cut -d. -f1`
			appPid=`head -1 ${VAR_DIR}/${pidFile}` # should use cat or head ???
			log INFO "GYMPB0116I: Application ${appName} is running on pid ${appPid}."
		done
	fi 
}

# Assuming USERS has modified this file
source ${DOCKER_DIR}/${ENV_FILE}

############################################################
## C O N T R O L L E R #####################################
############################################################

# Manage input arguments from here
if [ $# -lt 1 ]; then
	npidUsage
	exit -1
fi

if [ $# -gt 2 ]; then
	log WARNING "GYMPB0000W Too many arguments."
fi

ARG1=$1
ARG2=$2
# echo "ARG1: ${ARG1}, ARG2: ${ARG2}" # Development purpose only

case "${ARG1}" in
	start)
		startRoutine ${ARG2}
	;;
	stop)
		stopRountine ${ARG2}
	;;
	restart)
	;;
	kill)
	;;
	status)
		# statusRoutine
		if [ -z "${ARG2}" ]; then
			checkAllStatus
		else
			checkStatus ${ARG2}
		fi
	;;
	version)
		showVersion
	;;
	help)
	;;
	*)
	;;
esac

exit 2; 

############################################################
## M A I N #################################################
############################################################

echo "Starting Kafka"
KAFKA_LOG=${LOG_DIR}/${KAFKA}.log
${SH_SHELL} ${DOCKER_DIR}/${KAFKA}/${BOOTSTRAP} >>${KAFKA_LOG} 2>>${KAFKA_LOG} &
writePID ${KAFKA} ${!}
checkZookeeperStarted "dump" "/kafka/"
echo "Started Kafka"

echo "Starting Hadoop"
HADOOP_LOG=${LOG_DIR}/${HADOOP}.log
${BASH_SHELL} ${DOCKER_DIR}/${HADOOP}/${BOOTSTRAP} >>${HADOOP_LOG} 2>>${HADOOP_LOG} & # Need /bin/bash instead of /bin/sh ???
writePID ${HADOOP} ${!}
checkHadoop
echo "Started Hadoop"

echo "Starting NPI with Options"
NPI_LOG=${LOG_DIR}/${NPI}.log
${BASH_SHELL} ${DOCKER_DIR}/${NPI}/${BOOTSTRAP} >/dev/null 2>>${NPI_LOG} &
writePID ${NPI} ${!}
echo "Started NPI with Options"

exit 0

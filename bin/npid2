#!/bin/bash

############################################################
## C O N S T A N T S #######################################
############################################################
## New variables that are global
############################################################

# Application names
ZOOKEEPER_APP_NAME="zookeeper"
KAFKA_APP_NAME="kafka"
HADOOP_APP_NAME="hadoop"

# Application names (human readable)
ZOOKEEPER_READABLE="Zookeeper"
KAFKA_READABLE="Kafka"
HADOOP_READABLE="Hadoop"

# Reflects folder names inside docker directory
ZOOKEEPER="zk"
KAFKA="kafka"
HADOOP="spark_hadoop"
NPI="npi"

# Global stuffs around
TRY_COUNT=10
SLEEP_TIME=5

SCRIPT=$0
# Routine below facilitates the full qualified paths
if [ "`echo $0 | cut -c1`" = "." ]; then
   SCRIPT="`pwd`/`echo "$0" | sed 's/\.\///g'`"
elif [ "`echo $0 | cut -c1`" != "/" ]; then
   SCRIPT="`pwd`/$0"
fi

BIN_DIR=`dirname $SCRIPT`
PROG_DNAME=`basename $SCRIPT`
PROG_NAME=`echo $PROG_DNAME | sed s/.$//`
PROG_NAME2=`echo $PROG_NAME | sed s/d$//` # The correct product name
PROG_HOME=`dirname $BIN_DIR`
PROG_VERSION=`cat $BIN_DIR/$PROG_NAME2 | grep ^PROG_VERSION= | awk -F"=" '{print $2}'`

############################################################
## E N V # C O N D I T I O N I N G #########################
############################################################
# Re-using existing bootstraps from docker
DOCKER_DIR=${PROG_HOME}/docker
BOOTSTRAP="bootstrap.sh"
ENV_FILE="npi_env.sh"


# New environmental variables
SH_SHELL=`which sh`
BASH_SHELL=`which bash`
SERVICES_DIR=${PROG_HOME}/services

# New exports
export NPI_HOME=${PROG_HOME}
export NAMENODE=true
export USER_CONFIG=false
export HADOOP_PREFIX=${SERVICES_DIR}/hadoop
export STORAGE_URL=$HADOOP_NAMENODE_URL
export ZK_URL=$ZOOKEEP_URL
export ZKPREFIX=""

LOG_DIR=${PROG_HOME}/log
CONSOLE_LOG=${LOG_DIR}/${PROG_DNAME}.log
VAR_DIR=${PROG_HOME}/var

ZOOKEEPER_LOG=${LOG_DIR}/${ZOOKEEPER_APP_NAME}.log
KAFKA_LOG=${LOG_DIR}/${KAFKA}.log

if [ ! -d "${LOG_DIR}" ]; then
  mkdir -p ${LOG_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0100E: Create directory $LOG_DIR failed!  Check permissions on parent directory."
    exit 1
  fi
fi

if [ ! -d "${VAR_DIR}" ]; then
  mkdir -p ${VAR_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0101E: Create directory $VAR_DIR failed! Check permissions on parent directory."
    exit 1
  fi
fi

############################################################
## E X I S T I N G # F U N C T I O N S #####################
############################################################
log() {
  severity=$1
  shift
  timestamp=`date "+%Y-%m-%d %H:%M:%S.%N"|cut -b1-23`
  echo "[${severity}] [${timestamp}] [npid] $@" | tee -a ${CONSOLE_LOG}
}

showVersion() {
  log INFO "GYMPB0102I: Application: ${PROG_NAME2} Version: ${PROG_VERSION}"
  exit 0
}

############################################################
## N E W # F U N C T I O N S ###############################
############################################################

##
## E.g.
## npid start zookeeper
## npid start kafka
## npid start hadoop
##
## npid start npi - only starts npi
## npid start npi-storage
## npid start npi-analytics
## npid start npi-collector
## npid start npi-ui
##	
npidUsage() {
	echo "Usage: npid {start|stop|restart|kill|status|version|help} [all|<component_name>|<service_name>]"
	echo "component_name: npi, npi-storage, npi-analaytics, npi-collector, npi-ui"
	echo "service_name: zookeeper, kafka, hadoop"
	echo ""
	echo "Example: "
	echo "	1) npid start all"
	echo "	2) npid start npi-storage"
	echo "	3) npid start zookeeper"
	echo "	4) npid stop all"
}

##
## If 1 then log ERROR then exit with -1
## E.g. emergencyExit $status "GYM ..."
##
emergencyExit() {
	if [ ${1} -eq 1 ]; then
		log ERROR ${2}
		exit -1
	fi
}

##
## Check based on application name if, 
##	1. appplication PID file exist 
##	2. PID file is not empty
##	3. PID is found under ps ax
## Return 1 if found else 0
## E.g. 
##	isPidValid zookeeper
##	isPidValid npi-storage
##
isPidValid() {
	pidFile=${VAR_DIR}/${1}.pid

	if [ -f ${pidFile} ]; then 
		pid=`cat ${pidFile}`
		if [ -z "${pid}" ]; then # pid file is empty
			echo 0
		else # pid file not empty
			if [ -z "`ps ax | grep ${pid} | grep -v grep`" ]; then # pid is not within ps
				echo 0
			else # pid is valid within ps
				echo 1
			fi
		fi	
	else # no pid file exists
		echo 0
	fi
}

##
## Retrieve information from ps with grep name
## Expected to pass in the Application Name. E.g. zookeeper, hadoop
##
getPsByName() {
	echo "`ps ax | grep ${1} | grep -v grep | grep -v ${PROG_NAME}`"
}

##
## Created PID file based on application name. E.g. kafka.pid
##
writePID() {
	if [ $# -eq 2 ]
	then
		echo $2 > ${VAR_DIR}/${1}.pid # do we use >> instead ???
	else
		log ERROR "GYMPB0000E: Not enough arguments to write into PID file."
		exit 1
	fi
}

##
## Remove PID file based on application name. E.g. hadoop.pid
##
removePID() {
	rm ${VAR_DIR}/${1}.pid
}

##
## Get pid from PID file. E.g. hadoop.pid
##
getPID() {
	echo `cat ${VAR_DIR}/${1}.pid`
}


##
## Kill(15) pid and it's associated processes
##
killAssociatively() {
	ps -ef | grep ${1} | grep -v grep | awk '{print $2}' | xargs -i kill -15 {}
}

##
## Usage: stopApplication {<application_name>} {<application_readable_name>}
##
stopApplication() {
	log INFO "GYMPB0000I: Can we refactor all the stop*() functions ???"
}

# ===================
# = Zookeeper =======
# ===================

##
## Check if Zookeeper has started
## USAGE: checkZookeeperStarted <CMD> <PATTERN> <APPLICATION>
##
checkZookeeperStarted() {
	tryCount=${TRY_COUNT}
	isZookeeperUp=0
	host=`echo ${ZOOKEEP_URL} | cut -d: -f1`
	port=`echo ${ZOOKEEP_URL} | cut -d: -f2`

	while [ ${tryCount} -ne 0 ]; do
		ncResult=`echo ${1} | nc ${host} ${port} | grep ${2}`
		if [ ! -z "${ncResult}" ]; then
			isZookeeperUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isZookeeperUp} -eq 0 ]; then
		emergencyExit "1" "GYMPB0000E: ${3} is not starting."
	else
		log INFO "GYMPB0000I: ${3} has started"
	fi
}

startZookeeper() {
	status=`isPidValid "${ZOOKEEPER_APP_NAME}"`
	emergencyExit ${status} "GYMPB0000E: ${ZOOKEEPER_READABLE} is already running."

	log INFO "GYMPB0000I: About to start ${ZOOKEEPER_READABLE}"
	cd ${SERVICES_DIR}/${KAFKA_APP_NAME} && ./bin/zookeeper-server-start.sh ${SERVICES_DIR}/conf/${KAFKA_APP_NAME}/${ZOOKEEPER_APP_NAME}.properties >>${ZOOKEEPER_LOG} 2>>${ZOOKEEPER_LOG} &
	writePID ${ZOOKEEPER_APP_NAME} ${!}
	checkZookeeperStarted "stat" "Mode:" ${ZOOKEEPER_READABLE}
}

stopZookeeper() {
	log INFO "GYMPB0000I: About to stop ${ZOOKEEPER_READABLE}"
	# reference from https://github.com/linkedin/linkedin-zookeeper/blob/master/org.linkedin.zookeeper-server/src/cmdline/resources/bin/zkServer.sh
	pid=`getPID ${ZOOKEEPER_APP_NAME}`
	log DEBUG "GYMPB0000I: Attempting to kill processes associated with ${pid}"
	killAssociatively ${pid}

	tryCount=${TRY_COUNT}
	isZookeeperDown=0
	
	while [ $tryCount -ne 0 ]; do
		psStatus=`getPsByName ${ZOOKEEPER_APP_NAME}`
		if [ -z "${psStatus}" ]; then
			isZookeeperDown=1
			break
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isZookeeperDown} -eq 0 ]; then
		emergencyExit "1" "GYMPB0000E: ${ZOOKEEPER_READABLE} is not stopping."
	else
		log INFO "GYMPB0000I: ${ZOOKEEPER_READABLE} has stopped."
		removePID ${ZOOKEEPER_APP_NAME}
	fi
}

# ================
# = Kafka ========
# ================
checkKafkaDependency() {
	log INFO "GYMPB0000I: Do we need this ???"
}

startKafka() {
	status=`isPidValid "${KAFKA_APP_NAME}"`
	emergencyExit ${status} "GYMPB0000E: ${KAFKA_READABLE} is already running."

	log INFO "GYMPB0000I: About to start ${KAFKA_READABLE}"
	cd ${SERVICES_DIR}/${KAFKA_APP_NAME} && ./bin/kafka-server-start.sh ${SERVICES_DIR}/conf/${KAFKA_APP_NAME}/${KAFKA_APP_NAME}-server.properties >>${KAFKA_LOG} 2>>${KAFKA_LOG} &
	writePID ${KAFKA_APP_NAME} ${!}
	checkZookeeperStarted "dump" "/kafka/" ${KAFKA_READABLE}
}

stopKafka() {
	log INFO "GYMPB0000I: About to stop ${KAFKA_READABLE}"
	pid=`getPID ${KAFKA_APP_NAME}`
	log DEBUG "GYMPB0000I: Attempting to kill processes associated with ${pid}"
	killAssociatively ${pid}
	
	tryCount=${TRY_COUNT}
	isKafkaDown=0

	while [ $tryCount -ne 0 ]; do
		psStatus=`getPsByName ${KAFKA_APP_NAME}.${KAFKA_APP_NAME}` # reference from https://github.com/kafka-dev/kafka/blob/master/bin/kafka-server-stop.sh
		if [ -z "${psStatus}" ]; then
			isKafkaDown=1
			break
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isKafkaDown} -eq 0 ]; then
		emergencyExit "1" "GYMPB0000E: ${KAFKA_READABLE} is not stopping."
	else
		log INFO "GYMPB0000I: ${KAFKA_READABLE} has stopped."
		removePID ${KAFKA_APP_NAME}
	fi
}

# ==============
# = Hadoop =====
# ==============

##
## From bootstraps.sh
## Pending:
##	1. Need to save PID somewhere, $WAIT_PID; E.g. saveNameNodePid() { ... }
##
nn_service() {
	cmd=$1
	NAMENODES=$(${HADOOP_PREFIX}/bin/hdfs getconf -namenodes)
	
	log DEBUG "GYMPB0000I: ${cmd} namenodes on [${NAMENODES}]"
	
	"${HADOOP_PREFIX}/sbin/hadoop-daemon.sh" \
		--config "${HADOOP_CONF_DIR}" \
		--hostnames "${NAMENODES}" \
		--script "${HADOOP_PREFIX}/bin/hdfs" ${cmd} namenode 
	  
	SECONDARY_NAMENODES=$(${HADOOP_PREFIX}/bin/hdfs getconf -secondarynamenodes 2>/dev/null)
	
	if [ -n "${SECONDARY_NAMENODES}" ]; then
		log DEBUG "GYMPB0000I: ${cmd} secondary namenodes [${SECONDARY_NAMENODES}]"
	
	  	"${HADOOP_PREFIX}/sbin/hadoop-daemon.sh" \
			--config "${HADOOP_CONF_DIR}" \
			--hostnames "${SECONDARY_NAMENODES}" \
			--script "${HADOOP_PREFIX}/bin/hdfs" $cmd secondarynamenode
	  
		if [ ${WAIT_PID} -eq 0 ]; then
	  		WAIT_PID=$(cat /tmp/hadoop-*-secondarynamenode.pid |head -1)
	  	fi
	fi
    
    	if [ ${WAIT_PID} -eq 0 ];then
		WAIT_PID=$(cat /tmp/hadoop-*-namenode.pid |head -1)
    	fi
    
    	"${HADOOP_PREFIX}"/sbin/yarn-daemon.sh --config ${HADOOP_CONF_DIR} ${cmd} resourcemanager	
}

##
## Pending:
##	1. Need to save PID somewhere
##
dt_service() {
	cmd=${1}
	log DEBUG "GYMPB0000I: ${cmd} datanode"

	"${HADOOP_PREFIX}/sbin/hadoop-daemon.sh" \
		--config "${HADOOP_CONF_DIR}" \
	    	--script "${HADOOP_PREFIX}/bin/hdfs" ${cmd} datanode

	log DEBUG "GYMPB0000I: ${cmd} YARN nodemanager"

	"${HADOOP_PREFIX}"/sbin/yarn-daemon.sh --config ${HADOOP_CONF_DIR} ${cmd} nodemanager	
	if [ ${WAIT_PID} -eq 0 ];then
		WAIT_PID=$(cat /tmp/hadoop-*-datanode.pid |head -1)
	fi
}

##
## Comment:
## 	1. Not changing the paths to variables yet to remain apparent
##
copy_spark_jar_and_conf() {
	log DEBUG "GYMPB0000I: Waiting for recovering from safemode"
	$NPI_HOME/services/hadoop/bin/hdfs dfsadmin -safemode wait

	log DEBUG "GYMPB0000I: Creating /work/hadoop-conf folder"
	$NPI_HOME/services/hadoop/bin/hdfs dfs -mkdir -p /work/hadoop-conf

	log DEBUG "GYMPB0000I: Copying hadoop config files to hdfs"
	$NPI_HOME/services/hadoop/bin/hdfs dfs -copyFromLocal -f $NPI_HOME/services/hadoop/etc/hadoop/core-site.xml /work/hadoop-conf/core-site.xml
	$NPI_HOME/services/hadoop/bin/hdfs dfs -copyFromLocal -f $NPI_HOME/services/hadoop/etc/hadoop/hdfs-site.xml /work/hadoop-conf/hdfs-site.xml
	$NPI_HOME/services/hadoop/bin/hdfs dfs -copyFromLocal -f $NPI_HOME/services/hadoop/etc/hadoop/yarn-site.xml /work/hadoop-conf/yarn-site.xml
	$NPI_HOME/services/hadoop/bin/hdfs dfs -copyFromLocal -f $NPI_HOME/services/hadoop/etc/hadoop/spark-defaults.conf /work/hadoop-conf/spark-defaults.conf

	log DEBUG "Creating /work/spark-lib folder"
	$NPI_HOME/services/hadoop/bin/hdfs dfs -mkdir -p /work/spark-lib

	log DEBUG "Copying spark assembly jar to hdfs"
	$NPI_HOME/services/hadoop/bin/hdfs dfs -copyFromLocal -f $NPI_HOME/services/spark/lib/spark-assembly-*.jar /work/spark-lib/spark-assembly-hadoop.jar
}

##
## Comment:
##	1. Wrapper for calling initHadoopNameNode.sh
##
initHadoopNameNode() {
}

##
## There are initial errors not able surpress by this script ***
##
checkHadoop() {
	isHadoopUp=0
	tryCount=${TRY_COUNT}
	cmd="${HADOOP_PREFIX}/bin/hdfs dfsadmin -report"
	
	while [ ${tryCount} -ne 0 ]; do
		dfsAdminResult=`${cmd}`
		if [ ! -z "${dfsAdminResult}" ]; then
			isHadoopUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isHadoopUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: Hadoop is not starting."
		exit 1
	fi
	
	isHadoopUp=0
	tryCount=${TRY_COUNT}
	cmd="${HADOOP_PREFIX}/bin/hdfs dfs -ls ${HADOOP_NAMENODE_URL}"

	while [ ${tryCount} -ne 0 ]; do
		dfsResult=`${cmd} | grep "work"`
		if [ ! -z "${dfsResult}" ]; then
			isHadoopUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isHadoopUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: Hadoop is not starting."
		exit 1
	fi
}

startaHadoop() {
	a=1
}

stopHadoop() {
	a=1
}

# ===============
# = Npi =========
# ===============
startNpi() {
	a=1
}

stopNpi() {
	a=1
}

# ==========================
# = Start Rountine =========
# ==========================
startRoutine() {
	case "${1}" in
		"${ZOOKEEPER_APP_NAME}")
			startZookeeper
		;;
		"${KAFKA_APP_NAME}")
			startKafka
		;;
		*)
			log INFO "GYMPB0000I Application name is missing."
			npidUsage
		;;
	esac
}

# ==========================
# = Stop Rountine ==========
# ==========================
stopRountine() {
	case "${1}" in 
		"${ZOOKEEPER_APP_NAME}")
			stopZookeeper
		;;
		"${KAFKA_APP_NAME}")
			stopKafka
		;;
		*)
			log INFO "GYMPB0000I Application name is missing."
			npidUsage
		;;
	esac
}

# Check if any components related to Npi is running
checkIfAnyNpiRunning() {
	a=1
}

getPID() {
	if [ -f ${VAR_DIR}/${1}.pid ]; then
		echo -e `head -1 ${VAR_DIR}/${1}.pid` # cat or head ???
	else
		log ERROR "GYMPB0000E: PID does not exist."
		exit -1
	fi
}

##
## Each service or component should have it's own dedicated pid file
## 
##
checkStatus() {
	if [ -f ${VAR_DIR}/${1}.pid ]; then
		pid=`getPID ${1}`
		log INFO "GYMPB0116I: Application ${1} is running on pid ${pid}."
	else
		log INFO "GYMPB0117I: Application ${1} is not started."
	fi		
}

##
## Status dump for all components and services that is found in /var/*
##
checkAllStatus() {
	allAvailPidFile=`ls -1 ${VAR_DIR}`
	allAvailPidFile2=(${allAvailPidFile[*]}) # Transpose into array

	if [ ${#allAvailPidFile2[@]} -eq 0 ]; then
		log INFO "GYMPB0117I: No application started."
	else
		for pidFile in "${allAvailPidFile2[@]}"; do
			appName=`echo ${pidFile} | cut -d. -f1`
			appPid=`head -1 ${VAR_DIR}/${pidFile}` # should use cat or head ???
			log INFO "GYMPB0116I: Application ${appName} is running on pid ${appPid}."
		done
	fi 
}

# Assuming USERS has modified this file
source ${DOCKER_DIR}/${ENV_FILE}

############################################################
## C O N T R O L L E R #####################################
############################################################

# Manage input arguments from here
if [ $# -lt 1 ]; then
	npidUsage
	exit -1
fi

if [ $# -gt 2 ]; then
	log WARNING "GYMPB0000W Too many arguments."
fi

ARG1=$1
ARG2=$2
# echo "ARG1: ${ARG1}, ARG2: ${ARG2}" # Development purpose only

case "${ARG1}" in
	start)
		startRoutine ${ARG2}
	;;
	stop)
		stopRountine ${ARG2}
	;;
	restart)
	;;
	kill)
	;;
	status)
		# statusRoutine
		if [ -z "${ARG2}" ]; then
			checkAllStatus
		else
			checkStatus ${ARG2}
		fi
	;;
	version)
		showVersion
	;;
	help)
	;;
	*)
	;;
esac

exit 2; 

############################################################
## M A I N #################################################
############################################################

echo "Starting Hadoop"
HADOOP_LOG=${LOG_DIR}/${HADOOP}.log
${BASH_SHELL} ${DOCKER_DIR}/${HADOOP}/${BOOTSTRAP} >>${HADOOP_LOG} 2>>${HADOOP_LOG} & # Need /bin/bash instead of /bin/sh ???
writePID ${HADOOP} ${!}
checkHadoop
echo "Started Hadoop"

echo "Starting NPI with Options"
NPI_LOG=${LOG_DIR}/${NPI}.log
${BASH_SHELL} ${DOCKER_DIR}/${NPI}/${BOOTSTRAP} >/dev/null 2>>${NPI_LOG} &
writePID ${NPI} ${!}
echo "Started NPI with Options"

exit 0

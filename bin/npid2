#!/bin/bash

############################################################
## C O N S T A N T S #######################################
############################################################
## New variables that are global
############################################################
ZOOKEEPER="zk"
KAFKA="kafka"
HADOOP="spark_hadoop"
TRY_COUNT=5
SLEEP_TIME=5

SCRIPT=$0
# Routine below facilitates the full qualified paths
if [ "`echo $0 | cut -c1`" = "." ]; then
   SCRIPT="`pwd`/`echo "$0" | sed 's/\.\///g'`"
elif [ "`echo $0 | cut -c1`" != "/" ]; then
   SCRIPT="`pwd`/$0"
fi

BIN_DIR=`dirname $SCRIPT`
PROG_DNAME=`basename $SCRIPT`
PROG_NAME=`echo $PROG_DNAME | sed s/.$//`
PROG_HOME=`dirname $BIN_DIR`

############################################################
## E N V # C O N D I T I O N I N G #########################
############################################################
# Re-using existing bootstraps from docker
DOCKER_DIR=${PROG_HOME}/docker
BOOTSTRAP="bootstrap.sh"
ENV_FILE="npi_env.sh"


# New environmental variables
SH_SHELL=`which sh`
BASH_SHELL=`which bash`
SERVICES_DIR=${PROG_HOME}/services

# New exports
export NPI_HOME=${PROG_HOME}
export NAMENODE=true
export USER_CONFIG=false
export HADOOP_PREFIX=${SERVICES_DIR}/hadoop

LOG_DIR=${PROG_HOME}/log
CONSOLE_LOG=${LOG_DIR}/${PROG_DNAME}.log
VAR_DIR=${PROG_HOME}/var
PIDFILE=${VAR_DIR}/${PROG_NAME}.pid
PIDFILE2=${VAR_DIR}/frameworks.pid # temporary only

if [ ! -d "${LOG_DIR}" ]; then
  mkdir -p ${LOG_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0100E: Create directory $LOG_DIR failed!  Check permissions on parent directory."
    exit 1
  fi
fi

if [ ! -d "${VAR_DIR}" ]; then
  mkdir -p ${VAR_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0101E: Create directory $VAR_DIR failed! Check permissions on parent directory."
    exit 1
  fi
fi

############################################################
## E X I S T I N G # F U N C T I O N S #####################
############################################################
log()
{
  severity=$1
  shift
  timestamp=`date "+%Y-%m-%d %H:%M:%S.%N"|cut -b1-23`
  echo "[${severity}] [${timestamp}] [npid] $@" | tee -a ${CONSOLE_LOG}
}

# check ulimit parameters
check_ulimit_param() {
  parameter=$1
  name=$2
  minvalue=$3
  currentulimitvalue=`ulimit ${parameter}`
  if [ ${currentulimitvalue} -lt ${minvalue} ]; then
     #attempt to set ulimit
     local sout
     sout=$(ulimit -S ${parameter} ${minvalue} 2>&1)
     if [ "$?" != 0 ]; then
        log WARN "GYMPB0103W: ulimit parameter ${parameter} (${name}) is less than minimum value ${minvalue}! Fix by adding two lines to /etc/security/limits.conf: \"${USER} hard nofile ${minvalue}\" and \"${USER} soft nofile ${minvalue}\" and then log out the ${USER} user and log back in for the changes to take effect."
        log WARN "GYMPB0104W: Standard error from ulimit command is \"${sout}\""
     fi
  fi
}

# test UDP tuning parameters
check_sysctl_param() {
  parameter=$1
  minvalue=$2
  currentvalue=`/sbin/sysctl ${parameter} | awk -F'= ' '{print $2}'`
  if [ ${currentvalue} -lt ${minvalue} ]; then
    if [ "${ROOT}" = "YES" ]; then
       sysctl ${parameter}=${minvalue}
    else
       log ERROR "GYMPB0105E: sysctl parameter ${parameter}=${currentvalue} is less than required value ${minvalue}! Fix by adding \"${parameter}=${minvalue}\" to /etc/sysctl.conf and running sysctl -p as root. Alternatively, run ${PROG_NAME} as root."
       ERRORS=$(($ERRORS + 1))
    fi
  fi
}

check_parameters() {
  ERRORS=0
  # check if root
  if [ "${USER}" = "root" ]; then ROOT=YES; fi

  if [ "${IGNORESYSCHECK}" != "Y" ]; then
    check_ulimit_param "-n" "open files" 8096
    check_sysctl_param net.core.rmem_default 33554432
    check_sysctl_param net.core.rmem_max 33554432
    check_sysctl_param net.core.netdev_max_backlog 10000
    if [ "${ERRORS}" != "0" ]; then
      log ERROR "GYMPB0106E: Another kernel parameter error is fatal. Exiting. Check ${CONSOLE_LOG} for GYMPB0105E errors."
      exit 1
    fi
  fi
}

getPID() {
  FILEPID=`readPIDFile`
  PSPID=`findPID`
  ARG=$1
  if [ "$ARG" = "pidfile" ]; then
    RETURNPID=$FILEPID
  elif [ "$ARG" = "ps" ]; then
    RETURNPID=$PSPID
  else #return both
    RETURNPID=`echo -e "${FILEPID}\n${PSPID}" | sort | uniq | xargs`
  fi
  echo $RETURNPID
}

readPIDFile() {
  if [ -f "${PIDFILE}" ]; then
    FILEPID=`cat ${PIDFILE}`
  fi
  echo $FILEPID
}

findPID() {
  PSPID=`ps -eaf | grep -v grep | grep Dprog.name=${PROG_NAME} | awk '{print $2}' | xargs`
  echo $PSPID
}

startApplication()
{
  # check_parameters # to avoid annoying errors during development
  CHECK_PID=`getPID`
  if [ "${CHECK_PID}" != "" ]; then
    log ERROR "GYMPB0107E: Application $PROG_NAME is already running! (PID: $CHECK_PID)"
    exit 1
  fi
  cd ${PROG_HOME} 
  # bin/${PROG_NAME} $@ >/dev/null 2>>${CONSOLE_LOG} &
  bin/${PROG_NAME} $@ >>${CONSOLE_LOG} 2>>${CONSOLE_LOG} & # greedy logging
  PROG_PID=$!
  echo $PROG_PID > ${PIDFILE}
  sleep 5
  CHECK_PID=`getPID pidfile`
  if [ "${CHECK_PID}" = "" ]; then
    log ERROR "GYMPB0108E: Application ${PROG_NAME} started but died!  Check ${CONSOLE_LOG} and ${PROG_HOME}/log/${PROG_NAME}.log for errors."
    exit 1
  fi
  log INFO "GYMPB0109I: Application $PROG_NAME Version $PROG_VERSION started (PID: $PROG_PID)"
}

############################################################
## N E W # F U N C T I O N S ###############################
############################################################
writePID() 
{
	if [ $# -eq 2 ]
	then
		echo $1 $2 >> ${PIDFILE2}
	else
		log ERROR "GYMPB0000E: Not enough arguments to write into PID file."
		exit 1
	fi
}

##
## USAGE: checkZookeeper <CMD> <PATTERN>
##
checkZookeeper() {
	tryCount=${TRY_COUNT}
	isZookeeperUp=0
	host=`echo ${ZOOKEEP_URL} | cut -d: -f1`
	port=`echo ${ZOOKEEP_URL} | cut -d: -f2`

	while [ ${tryCount} -ne 0 ]; do
		ncResult=`echo ${1} | nc ${host} ${port} | grep ${2}`
		if [ ! -z "${ncResult}" ]; then
			isZookeeperUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isZookeeperUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: Zookeeper / Kafka is not starting."
		exit 1
	fi
}

##
## There are initial errors not able surpress by this script ***
##
checkHadoop() {
	isHadoopUp=0
	tryCount=${TRY_COUNT}
	cmd="${HADOOP_PREFIX}/bin/hdfs dfsadmin -report"
	
	while [ ${tryCount} -ne 0 ]; do
		dfsAdminResult=`${cmd}`
		if [ ! -z "${dfsAdminResult}" ]; then
			isHadoopUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isHadoopUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: Hadoop is not starting."
		exit 1
	fi
	
	isHadoopUp=0
	tryCount=${TRY_COUNT}
	cmd="${HADOOP_PREFIX}/bin/hdfs dfs -ls ${HADOOP_NAMENODE_URL}"

	while [ ${tryCount} -ne 0 ]; do
		dfsResult=`${cmd} | grep "work"`
		if [ ! -z "${dfsResult}" ]; then
			isHadoopUp=1
			break			
		fi
		sleep ${SLEEP_TIME}
		tryCount=$(( ${tryCount} - 1 ))
	done

	if [ ${isHadoopUp} -eq 0 ]; then
		log ERROR "GYMPB0000E: Hadoop is not starting."
		exit 1
	fi
}

# Assuming USERS has modified this file
source ${DOCKER_DIR}/${ENV_FILE}

echo "Starting Zookeeper"
ZOOKEEPER_LOG=${LOG_DIR}/${ZOOKEEPER}.log
${SH_SHELL} ${DOCKER_DIR}/${ZOOKEEPER}/${BOOTSTRAP} >>${ZOOKEEPER_LOG} 2>>${ZOOKEEPER_LOG} & # Everything into log file
writePID ${ZOOKEEPER} ${!}
checkZookeeper "stat" "Mode:"
echo "Started Zookeeper"

# Check for log message before proceed ??? For each framework processes

echo "Starting Kafka"
KAFKA_LOG=${LOG_DIR}/${KAFKA}.log
${SH_SHELL} ${DOCKER_DIR}/${KAFKA}/${BOOTSTRAP} >>${KAFKA_LOG} 2>>${KAFKA_LOG} &
writePID ${KAFKA} ${!}
checkZookeeper "dump" "/kafka/"
echo "Started Kafka"

echo "Starting Hadoop"
HADOOP_LOG=${LOG_DIR}/${HADOOP}.log
${BASH_SHELL} ${DOCKER_DIR}/${HADOOP}/${BOOTSTRAP} >>${HADOOP_LOG} 2>>${HADOOP_LOG} & # Need /bin/bash instead of /bin/sh ???
writePID ${HADOOP} ${!}
checkHadoop
echo "Started Hadoop"

echo "Starting NPI with Options"
startApplication # This might not be correct
echo "Started NPI with Options"

exit 0

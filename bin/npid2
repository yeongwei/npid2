#!/bin/bash

## =========================================================
## New variables that are global
## =========================================================

# Application names
ZOOKEEPER_APP_NAME="zookeeper"
KAFKA_APP_NAME="kafka"
HADOOP_APP_NAME="hadoop"
NPI_APP_NAME="npi" # Gonna deprecate soon
NPI_STORAGE_APP_NAME="npi-storage" # storage
NPI_ANALYTICS_APP_NAME="npi-analytics" # analytics
NPI_COLLECTOR_APP_NAME="npi-collector" # collector
NPI_UI_APP_NAME="npi-ui" # ui

# Application names (human readable)
ZOOKEEPER_READABLE="Zookeeper"
KAFKA_READABLE="Kafka"
HADOOP_READABLE="Hadoop"
NPI_READABLE="NPI"
NPI_STORAGE_READABLE="Storage"
NPI_ANALYTICS_READABLE="Analytics"
NPI_COLLECTOR_READABLE="Collector"
NPI_UI_READABLE="UI"

# Reflects folder names inside docker directory
ZOOKEEPER="zk"
KAFKA="kafka"
HADOOP="spark_hadoop"
NPI="npi"

# Global parameters
TRY_COUNT=10
SLEEP_TIME=5

SCRIPT=$0
# Routine below facilitates the full qualified paths
if [ "`echo $0 | cut -c1`" = "." ]; then
   SCRIPT="`pwd`/`echo "$0" | sed 's/\.\///g'`"
elif [ "`echo $0 | cut -c1`" != "/" ]; then
   SCRIPT="`pwd`/$0"
fi

BIN_DIR=`dirname $SCRIPT`
PROG_DNAME=`basename $SCRIPT`
PROG_NAME=`echo $PROG_DNAME | sed s/.$//`
PROG_NAME2=`echo $PROG_NAME | sed s/d$//` # The correct product name
PROG_HOME=`dirname $BIN_DIR`
PROG_VERSION=`cat $BIN_DIR/$PROG_NAME2 | grep ^PROG_VERSION= | awk -F"=" '{print $2}'`

## =========================================================
## New variables that are global
## =========================================================
# Re-using existing bootstraps from docker
DOCKER_DIR=${PROG_HOME}/docker
BOOTSTRAP="bootstrap.sh"
ENV_FILE="npi_env.sh"


# New environmental variables
SH_SHELL=`which sh`
BASH_SHELL=`which bash`
SERVICES_DIR=${PROG_HOME}/services
RESOURCES_DIR=${BIN_DIR}/resources

# Environment exports
# Pending:
#	1. Need to segregate out exports for each individual application
export NPI_HOME=${PROG_HOME}

export NAMENODE=true
export USER_CONFIG=false

export HADOOP_PREFIX=${SERVICES_DIR}/hadoop
export STORAGE_URL=$HADOOP_NAMENODE_URL
export ZK_URL=$ZOOKEEP_URL
export ZKPREFIX=""

LOG_DIR=${PROG_HOME}/log
CONSOLE_LOG=${LOG_DIR}/${PROG_DNAME}.log
VAR_DIR=${PROG_HOME}/var

# Logs
ZOOKEEPER_LOG=${LOG_DIR}/${ZOOKEEPER_APP_NAME}.log
KAFKA_LOG=${LOG_DIR}/${KAFKA_APP_NAME}.log
HADOOP_LOG=${LOG_DIR}/${HADOOP_APP_NAME}.log
NPI_LOG=${LOG_DIR}/${NPI_APP_NAME}.log

if [ ! -d "${LOG_DIR}" ]; then
  mkdir -p ${LOG_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0100E: Create directory $LOG_DIR failed!  Check permissions on parent directory."
    exit 1
  fi
fi

if [ ! -d "${VAR_DIR}" ]; then
  mkdir -p ${VAR_DIR}
  if [ "$?" != 0 ]; then
    log ERROR "GYMPB0101E: Create directory $VAR_DIR failed! Check permissions on parent directory."
    exit 1
  fi
fi

## =========================================================
## Existing functions
## =========================================================
log() {
  severity=$1
  shift
  timestamp=`date "+%Y-%m-%d %H:%M:%S.%N"|cut -b1-23`
  echo "[${severity}] [${timestamp}] [npid] $@" | tee -a ${CONSOLE_LOG}
}

showVersion() {
  log INFO "GYMPB0102I: Application: ${PROG_NAME2} Version: ${PROG_VERSION}"
  exit 0
}

# ======================================
# Source shell scripts 
# ======================================
source ${RESOURCES_DIR}/functions
source ${RESOURCES_DIR}/zookeeperFunctions
source ${RESOURCES_DIR}/kafkaFunctions
source ${RESOURCES_DIR}/hadoopFunctions
source ${RESOURCES_DIR}/npiFunctions
source ${RESOURCES_DIR}/routines

# Assuming USERS has modified this file
# Pending:
# 	1. The npi_env.sh needs to be updated accordingly
source ${DOCKER_DIR}/${ENV_FILE}

## =========================================================
## Controller
## =========================================================

# Manage input arguments from here
if [ $# -lt 1 ]; then
	npidUsage
	exit -1
fi

if [ $# -gt 2 ]; then
	log WARNING "GYMPB0000W: Too many arguments."
fi

ARG1=$1
ARG2=$2

case "${ARG1}" in
	start)
		startRoutine ${ARG2}
	;;
	stop)
		stopRountine ${ARG2}
	;;
	restart)
		restartRoutine ${ARG2}
	;;
	kill)
	;;
	status)
		statusRoutine ${ARG2}
	;;
	version)
		showVersion
	;;
	help)
	;;
	*)
	;;
esac

exit 0
